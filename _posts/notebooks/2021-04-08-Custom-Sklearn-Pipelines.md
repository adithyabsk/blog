---
keywords: fastai
title: How to use Custom Sklearn Classes and Pipelines
toc: false
badges: true
comments: true
category: datascience
description: How to use Scikit-Learn's deeper features to build custom models and transformers.
image: images/copied_from_nb/sklearn.png
nb_path: _notebooks/2021-04-08-Custom-Sklearn-Pipelines.ipynb
layout: notebook
---

<!--
#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: _notebooks/2021-04-08-Custom-Sklearn-Pipelines.ipynb
-->

<div class="container" id="notebook-container">
        
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><img src="/images/copied_from_nb/sklearn.png" alt="Sklearn Cover Photo"></p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Introduction">Introduction<a class="anchor-link" href="#Introduction"> </a></h2><p><a href="https://github.com/scikit-learn/scikit-learn">Scikit-learn</a> (or <code>sklearn</code>) is the machine learning tool of choice for exploratory analysis by data scientists. It has over 45k stars on GitHub and was downloaded <a href="https://pypistats.org/packages/scikit-learn">over 7 million times</a> in the last month (March 2021) Their <code>fit</code> / <code>transform</code> / <code>predict</code> API is now ubiquitous in the python machine learning ecosystem with many other open source projects choosing to be compatible with that API.</p>
<h3 id="Motivation">Motivation<a class="anchor-link" href="#Motivation"> </a></h3><p>In order to leverage the deeper features of the <code>sklearn</code> platform, it is useful to build custom data transformation pipelines using the provided classes. In this blog post, we will focus on using <a href="https://scikit-learn.org/stable/modules/generated/sklearn.base.TransformerMixin.html">Custom Transformers</a> and <a href="https://scikit-learn.org/stable/modules/generated/sklearn.pipeline.Pipeline.html">Pipelines</a> which are essential to delivering replicable results.</p>
<p>When dealing with real-world data, it is often difficult to convert data manipulations into repeatable steps: this is where custom transformers come into play. Additionally, you might then want to apply these custom transformations in sequence. This is where <code>Pipelines</code> become useful. Putting these two tools together, you have a powerful playbook to handle all the messy data the real world throws at you.</p>
<div class="flash">
<b>Note:</b> This blog post assumes that you already have a basic understanding of the <code>sklearn</code> API and concepts such as <code>fit</code> / <code>transform</code> / <code>predict</code> and so on. If some of that is new to you, please check out <a href="https://scikit-learn.org/stable/tutorial/basic/tutorial.html">this fantastic page in the `sklearn` docs.</a>
</div>
</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># Install Required packages</span>
<span class="c1"># Python 3.8</span>
<span class="o">!</span>pip install --upgrade pip
<span class="o">!</span>pip install <span class="nv">kaggle</span><span class="o">==</span><span class="m">1</span>.5.12
<span class="o">!</span>pip install scikit-learn<span class="o">==</span><span class="m">0</span>.24.1
<span class="o">!</span>pip install <span class="nv">pandas</span><span class="o">==</span><span class="m">1</span>.2.3
<span class="o">!</span>pip install python-dotenv<span class="o">==</span><span class="m">0</span>.17.0
<span class="o">!</span>pip install <span class="nv">fastcore</span><span class="o">==</span><span class="m">1</span>.3.19
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>
<span class="kn">from</span> <span class="nn">pprint</span> <span class="kn">import</span> <span class="n">pprint</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">fastcore.basics</span> <span class="kn">import</span> <span class="n">patch</span>
<span class="kn">from</span> <span class="nn">pandas</span> <span class="kn">import</span> <span class="n">json_normalize</span>
<span class="kn">from</span> <span class="nn">sklearn.base</span> <span class="kn">import</span> <span class="n">BaseEstimator</span><span class="p">,</span> <span class="n">ClassifierMixin</span><span class="p">,</span> <span class="n">TransformerMixin</span><span class="p">,</span> <span class="n">clone</span>
<span class="kn">from</span> <span class="nn">sklearn.feature_extraction</span> <span class="kn">import</span> <span class="n">DictVectorizer</span>
<span class="kn">from</span> <span class="nn">sklearn.feature_extraction.text</span> <span class="kn">import</span> <span class="n">TfidfTransformer</span>
<span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">LogisticRegression</span>
<span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">accuracy_score</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">train_test_split</span>
<span class="kn">from</span> <span class="nn">sklearn.pipeline</span> <span class="kn">import</span> <span class="n">Pipeline</span>
<span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">FunctionTransformer</span><span class="p">,</span> <span class="n">OrdinalEncoder</span>
<span class="kn">from</span> <span class="nn">sklearn.utils.validation</span> <span class="kn">import</span> <span class="n">check_array</span><span class="p">,</span> <span class="n">check_is_fitted</span>

<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>

<span class="n">SklearnInput</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">]</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="The-Dataset">The Dataset<a class="anchor-link" href="#The-Dataset"> </a></h2><p>In this blog post we'll be using the motivating example of
<a href="https://www.kaggle.com/roamresearch/prescriptionbasedprediction">the Prescription Based Prediction (PBP) dataset</a>. The
PBP dataset combines the frequencies of prescribed medication under Medicare part D with practitioner data  from the
National Provider Identifier dataset. The authors of this aggregate dataset had a corresponding blog post explaining the
dataset in a bit more detail. It is no longer live, but it is still available on
<a href="https://web.archive.org/web/20180211230833/http://roamanalytics.com:80/2016/09/13/prescription-based-prediction/#The-target-variables-and-their-relationships">The Wayback Machine</a>.</p>
<div class="d-flex flex-justify-center">
<a href="https://www.medicare.gov/" style="width:50%">
{% include image.html alt="Medicare Logo" file="https://assets-global.website-files.com/59d3b5e54e9881000114dd8b/5da5f673cddab7fa97f6cf62_medicare.jpg" %}
</a>
</div><div class="flash">
<b>Note:</b> You'll need to configure your Kaggle API credentials to download the dataset or, you can simply go to Kaggle and manually unzip the data into the notebook folder. Simply uncomment the next line and replace it with your kaggle credentials. <a href="https://github.com/Kaggle/kaggle-api#api-credentials">Read more about this here.</a>
</div>
</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span> 
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">from</span> <span class="nn">dotenv</span> <span class="kn">import</span> <span class="n">load_dotenv</span>

<span class="n">load_dotenv</span><span class="p">()</span>
<span class="kn">import</span> <span class="nn">kaggle</span>

<span class="n">kaggle</span><span class="o">.</span><span class="n">api</span><span class="o">.</span><span class="n">authenticate</span><span class="p">()</span>
<span class="n">kaggle</span><span class="o">.</span><span class="n">api</span><span class="o">.</span><span class="n">dataset_download_files</span><span class="p">(</span>
    <span class="s2">&quot;roamresearch/prescriptionbasedprediction&quot;</span><span class="p">,</span> <span class="n">unzip</span><span class="o">=</span><span class="kc">True</span>
<span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The data itself is in the uncommon <code>.jsonl</code> format which is a newline delimited dataset. Each line contains a <code>json</code> object. We can use pandas to read this dataset into a <code>pd.DataFrame</code>.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">FPATH</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s2">&quot;/work/roam_prescription_based_prediction.jsonl&quot;</span><span class="p">)</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_json</span><span class="p">(</span><span class="n">FPATH</span><span class="p">,</span> <span class="n">lines</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">orient</span><span class="o">=</span><span class="s2">&quot;columns&quot;</span><span class="p">)</span>
<span class="n">df</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_html rendered_html output_subarea output_execute_result">
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>cms_prescription_counts</th>
      <th>provider_variables</th>
      <th>npi</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>{'DOXAZOSIN MESYLATE': 26, 'MIDODRINE HCL': 12...</td>
      <td>{'settlement_type': 'non-urban', 'generic_rx_c...</td>
      <td>1295763035</td>
    </tr>
    <tr>
      <th>1</th>
      <td>{'CEPHALEXIN': 23, 'AMOXICILLIN': 52, 'HYDROCO...</td>
      <td>{'settlement_type': 'non-urban', 'generic_rx_c...</td>
      <td>1992715205</td>
    </tr>
    <tr>
      <th>2</th>
      <td>{'CEPHALEXIN': 28, 'AMOXICILLIN': 73, 'CLINDAM...</td>
      <td>{'settlement_type': 'non-urban', 'generic_rx_c...</td>
      <td>1578587630</td>
    </tr>
  </tbody>
</table>
</div>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>To understand this data a bit better, lets explode both of the <code>json</code> variables in the first row. We can use the <code>pandas</code> builtin function <code>json_normalize</code> which converts a <code>json</code> dictionary into a flat table.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">json_normalize</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">cms_prescription_counts</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_html rendered_html output_subarea output_execute_result">
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>DOXAZOSIN MESYLATE</th>
      <th>MIDODRINE HCL</th>
      <th>MEGESTROL ACETATE</th>
      <th>BENAZEPRIL HCL</th>
      <th>METOLAZONE</th>
      <th>NOVOLOG</th>
      <th>DIAZEPAM</th>
      <th>HYDRALAZINE HCL</th>
      <th>SENSIPAR</th>
      <th>LABETALOL HCL</th>
      <th>...</th>
      <th>RENVELA</th>
      <th>ABILIFY</th>
      <th>SERTRALINE HCL</th>
      <th>CIPROFLOXACIN HCL</th>
      <th>SIMVASTATIN</th>
      <th>PRAVASTATIN SODIUM</th>
      <th>ATENOLOL-CHLORTHALIDONE</th>
      <th>ALPRAZOLAM</th>
      <th>AZITHROMYCIN</th>
      <th>TRAMADOL HCL</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>26</td>
      <td>12</td>
      <td>11</td>
      <td>11</td>
      <td>73</td>
      <td>12</td>
      <td>24</td>
      <td>50</td>
      <td>94</td>
      <td>28</td>
      <td>...</td>
      <td>117</td>
      <td>11</td>
      <td>14</td>
      <td>19</td>
      <td>14</td>
      <td>13</td>
      <td>53</td>
      <td>45</td>
      <td>18</td>
      <td>11</td>
    </tr>
  </tbody>
</table>
<p>1 rows × 68 columns</p>
</div>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">json_normalize</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">provider_variables</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_html rendered_html output_subarea output_execute_result">
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>settlement_type</th>
      <th>generic_rx_count</th>
      <th>specialty</th>
      <th>years_practicing</th>
      <th>gender</th>
      <th>region</th>
      <th>brand_name_rx_count</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>non-urban</td>
      <td>2287</td>
      <td>Nephrology</td>
      <td>7</td>
      <td>M</td>
      <td>South</td>
      <td>384</td>
    </tr>
  </tbody>
</table>
</div>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Cool, let's now see what the distribution of those variables looks like.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">json_normalize</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;provider_variables&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">settlement_type</span><span class="o">.</span><span class="n">value_counts</span><span class="p">()</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>non-urban    152270
urban         87660
Name: settlement_type, dtype: int64</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">json_normalize</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;provider_variables&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">region</span><span class="o">.</span><span class="n">value_counts</span><span class="p">()</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>South        80562
Northeast    59012
West         50279
Midwest      50077
Name: region, dtype: int64</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>It looks like the <code>cms_prescription_counts</code> column contains a <code>json</code> dictionary with the names of each drug followed by the count. The <code>provider_variables</code> column seems to have a <code>json</code> dictionary that contains information about the provider who prescribed the drugs.</p>
<p>It might be interesting to build a few models that predict some of these variables given the prescribed drugs and counts. In this blog post, we'll focus on estimating the <code>settlement_type</code> and the <code>region</code>.</p>
<p>Let's set the feature and response variables to their appropriate column and convert them to native Python lists. Let's also split the data into a train and validation set.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">TEST_PCT</span> <span class="o">=</span> <span class="mf">0.2</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">cms_prescription_counts</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">provider_variables</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="n">TEST_PCT</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Custom-Transformers">Custom Transformers<a class="anchor-link" href="#Custom-Transformers"> </a></h2><p>Developing <code>sklearn</code> API compatible transformers will allow us to make full use of other aspects of the library. In this example, we'll implement two custom transformers that leverage sklearn <a href="https://scikit-learn.org/stable/modules/classes.html#module-sklearn.base">base classes</a> to transform the response variable in the dataset.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="JSONTargetSelector">JSONTargetSelector<a class="anchor-link" href="#JSONTargetSelector"> </a></h3><p>First, let's build a way to quickly extract a desired response variable from <code>y</code>. We start by defining a class that inherits from <code>TransformerMixin</code> which gives us the <code>fit_transform</code> method if we define the <code>fit</code> and <code>transform</code> methods.</p>
<p>Next up, we define the constructor which requires two variables that tell us the key to extract from each <code>json</code> row and the dimensions of the data output. We also include an <code>is_fit_</code> attribute which lets <code>sklearn</code> helper functions know that this transformer is already been "fitted" (i.e. it doesn't need to be fit)</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">class</span> <span class="nc">JSONTargetSelector</span><span class="p">(</span><span class="n">TransformerMixin</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;From a list of json blobs select a particular key and compose a new list of those values.</span>

<span class="sd">    Args:</span>
<span class="sd">        target_name: The json key to extract in each row</span>
<span class="sd">        two_d_out: Whether the output transformation should be 2d</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">two_d_out</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_name</span> <span class="o">=</span> <span class="n">target_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">two_d_out</span> <span class="o">=</span> <span class="n">two_d_out</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_fit_</span> <span class="o">=</span> <span class="kc">True</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Now, let's add the <code>fit</code> method. It is empty because we already have all the information we need to transform input data from the constructor alone. We return <code>self</code> (the object instance) as per convention.</p>
<div class="flash">
<b>Note:</b> Here we use the neat <a href="https://fastcore.fast.ai/basics.html#patch"><code>@patch</code></a> decorator to add instance methods to the class so that we don't have to have all of the code in a single jupyter cell.
</div>
</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="nd">@patch</span>
<span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">JSONTargetSelector</span><span class="p">,</span> <span class="n">X</span><span class="p">:</span> <span class="n">SklearnInput</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">SklearnInput</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Now let's add the transform functionality. We break this up into the two methods. The <code>_extract_target</code> method allows us to pull a particular key out of an input dictionary while also validating that the inputs are as we expect them. The <code>transform</code> method does the meat of the data conversion. It turns a list of <code>json</code> objects to a flat list of selected values.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="nd">@patch</span>
<span class="k">def</span> <span class="nf">_extract_target</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">JSONTargetSelector</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">json_dict</span><span class="p">:</span> <span class="nb">dict</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get the target key from a dictionary.</span>

<span class="sd">    Args:</span>
<span class="sd">        index: the index of the current row</span>
<span class="sd">        json_dict: potentially a json dictionary which has `target_name` as a key</span>

<span class="sd">    Returns:</span>
<span class="sd">        The value of the `target_name` key.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If `json_dict` is not a dictionary</span>
<span class="sd">        ValueError: If `target_name` is not in the `json_dict`</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">json_dict</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;item at index </span><span class="si">{</span><span class="n">index</span><span class="si">}</span><span class="s2"> is not a dictionary.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">json_dict</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;index </span><span class="si">{</span><span class="n">index</span><span class="si">}</span><span class="s2"> is missing target </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">target_name</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">json_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">target_name</span><span class="p">)</span>


<span class="nd">@patch</span>
<span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">JSONTargetSelector</span><span class="p">,</span> <span class="n">X</span><span class="p">:</span> <span class="n">SklearnInput</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">SklearnInput</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">check_array</span><span class="p">(</span>
        <span class="n">X</span><span class="p">,</span> <span class="n">accept_sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">force_all_finite</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ensure_2d</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;object&quot;</span>
    <span class="p">)</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_extract_target</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">Xi</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">Xi</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">X</span><span class="p">))])</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">two_d_out</span><span class="p">:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">out</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Lastly, let's add the identity function as the inverse transform. There is no meaningful inverse since we lose data during the transform and future sections will require this function to have an implementation.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="nd">@patch</span>
<span class="k">def</span> <span class="nf">inverse_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">JSONTargetSelector</span><span class="p">,</span> <span class="n">X</span><span class="p">:</span> <span class="n">SklearnInput</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">X</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We can test that the above implementation works with some fake data. Given we selects <code>"c"</code> as the desired key, we should see <code>[2 4 8]</code> in the output which is exactly what we observe.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="s2">&quot;abcd&quot;</span><span class="p">))}</span>
<span class="n">list_of_dict</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span><span class="p">,</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">()},</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span><span class="o">**</span><span class="mi">3</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">()}]</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;List of Dicts&quot;</span><span class="p">)</span>
<span class="n">pprint</span><span class="p">(</span><span class="n">list_of_dict</span><span class="p">)</span>
<span class="nb">print</span><span class="p">()</span>

<span class="n">selected_key</span> <span class="o">=</span> <span class="s2">&quot;c&quot;</span>
<span class="n">jts</span> <span class="o">=</span> <span class="n">JSONTargetSelector</span><span class="p">(</span><span class="n">selected_key</span><span class="p">)</span>
<span class="n">jts_trans</span> <span class="o">=</span> <span class="n">jts</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">list_of_dict</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Transformed Data&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">jts_trans</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>List of Dicts
[{&#39;a&#39;: 0, &#39;b&#39;: 1, &#39;c&#39;: 2, &#39;d&#39;: 3},
 {&#39;a&#39;: 0, &#39;b&#39;: 1, &#39;c&#39;: 4, &#39;d&#39;: 9},
 {&#39;a&#39;: 0, &#39;b&#39;: 1, &#39;c&#39;: 8, &#39;d&#39;: 27}]

Transformed Data
[2 4 8]
</pre>
</div>
</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="TransformedTargetClassifier">TransformedTargetClassifier<a class="anchor-link" href="#TransformedTargetClassifier"> </a></h3><p><em>Phew</em>, alright now that we've got that class completed we need to build a wrapper class that will allow us to actually use it in downstream applications.</p>
<p>Why, you may ask? In our case, we want a simple way to both transform the response variable and estimate on the response variable. Building a composite meta estimator is the way to go here considering the broader API constraints. To be honest, it's a bit of a quirk in the way the <code>sklearn</code> API was originally designed. By that, I mean that the original API design does not really take into account the possibility of transforming the response variable (specifically using <code>Pipelines</code> which we'll see in just a bit).</p>
<p><code>sklearn</code> already has addressed that flaw with a built-in meta estimator called <code>TransformedTargetRegressor</code>, but unfortunately, it only works for regression estimators. (e.g. applying a log transform to your response variable) In our case, we are looking at a binary classification problem, so we'll need to roll our own.</p>
<p>First, let's define a constructor which takes in an instance of a classifier and a transformer.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">class</span> <span class="nc">TransformedTargetClassifier</span><span class="p">(</span><span class="n">ClassifierMixin</span><span class="p">,</span> <span class="n">BaseEstimator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A meta estimator that both transforms the response variable.</span>

<span class="sd">    Args:</span>
<span class="sd">        classifier: An instance of a class that inherits from BaseEstimator</span>
<span class="sd">        transformer: An instance of a class that inherits from TransformerMixin</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">classifier</span><span class="p">:</span> <span class="n">BaseEstimator</span><span class="p">,</span> <span class="n">transformer</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">TransformerMixin</span><span class="p">,</span> <span class="n">Pipeline</span><span class="p">]</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">classifier</span> <span class="o">=</span> <span class="n">classifier</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transformer</span> <span class="o">=</span> <span class="n">transformer</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Now when fitting this meta estimator, we need to fit both the classifier and the transformer. But first, we need to quickly validate the input y array. Stealing a bit of code from <code>TransformTargetRegressor</code> we can validate both the datatypes and shape of the inputs.</p>
<p>We use <code>check_array</code> which is a validation function from <code>sklearn</code> which converts inputs into <code>np.ndarray</code> form and validates a bunch of other things for us. We follow this with a bit of code to make sure that the dimensions of the response variable are correct. This is so that we can handle either the user passing a row vector or a column vector.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="nd">@patch</span>
<span class="k">def</span> <span class="nf">fit</span><span class="p">(</span>  <span class="c1"># noqa: F811</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">TransformedTargetClassifier</span><span class="p">,</span>
    <span class="n">X</span><span class="p">:</span> <span class="n">SklearnInput</span><span class="p">,</span>
    <span class="n">y</span><span class="p">:</span> <span class="n">SklearnInput</span><span class="p">,</span>
    <span class="o">**</span><span class="n">fit_params</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
<span class="p">):</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">check_array</span><span class="p">(</span>
        <span class="n">y</span><span class="p">,</span> <span class="n">accept_sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">force_all_finite</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ensure_2d</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;object&quot;</span>
    <span class="p">)</span>
    <span class="c1"># store the original dimensions of y</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_training_dim</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">ndim</span>
    <span class="k">if</span> <span class="n">y</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">y_2d</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">y_2d</span> <span class="o">=</span> <span class="n">y</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">transformer</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">y_2d</span><span class="p">)</span>
    <span class="n">y_trans</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformer</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">y_2d</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">classifier</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y_trans</span><span class="p">,</span> <span class="o">**</span><span class="n">fit_params</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">is_fit_</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">return</span> <span class="bp">self</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>With the <code>fit</code> method in place, we turn our attention to <code>predict</code> which is where the magic happens.</p>
<p>We use the <code>check_is_fitted</code> method to make sure that the particular transformer is fit. <code>sklearn</code> has an internal convention which checks for a variable to exist with a trailing underscore (<code>_</code>) to know if an instance has been fit. Since we don't know the exact classifier or transformer, we cannot get any more specific than that. Unfortunately, <code>Pipelines</code> <a href="https://stackoverflow.com/questions/63027527/sklearn-pipeline-not-fitted-after-fit-has-been-called#comment111476677_63027527">do not set the conventional attributes at fit time</a> so we have no way of knowing if it has been fitted.</p>
<p>Next, we run the predict step of the classifier and run an inverse transformation on its output. (running the fit steps in reverse) This was why we made sure to define the <code>inverse_transform</code> method in our previous custom transformer. After that, we make sure to handle data dimension issues before returning the output.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="nd">@patch</span>
<span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">TransformedTargetClassifier</span><span class="p">,</span> <span class="n">X</span><span class="p">:</span> <span class="n">SklearnInput</span><span class="p">):</span>
    <span class="n">check_is_fitted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">classifier</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transformer</span><span class="p">,</span> <span class="n">Pipeline</span><span class="p">):</span>
        <span class="n">check_is_fitted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transformer</span><span class="p">)</span>

    <span class="n">pred</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">classifier</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">pred</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">pred</span> <span class="o">=</span> <span class="n">pred</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">pred_trans</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformer</span><span class="o">.</span><span class="n">inverse_transform</span><span class="p">(</span><span class="n">pred</span><span class="p">)</span>

    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_training_dim</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">pred_trans</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">pred_trans</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">pred_trans</span> <span class="o">=</span> <span class="n">pred_trans</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">pred_trans</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Lastly, we have to add an updated <code>score</code> method. We cannot simply just use the <a href="https://github.com/scikit-learn/scikit-learn/blob/95119c13af77c76e150b753485c662b7c52a41a2/sklearn/base.py#L470">inherited scoring</a> method since we need to transform the ground truth variable before scoring. We use accuracy just the same as the super class.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="nd">@patch</span>
<span class="k">def</span> <span class="nf">score</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">TransformedTargetClassifier</span><span class="p">,</span>
    <span class="n">X</span><span class="p">:</span> <span class="n">SklearnInput</span><span class="p">,</span>
    <span class="n">y</span><span class="p">:</span> <span class="n">SklearnInput</span><span class="p">,</span>
    <span class="n">sample_weight</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">check_array</span><span class="p">(</span>
        <span class="n">y</span><span class="p">,</span> <span class="n">accept_sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">force_all_finite</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ensure_2d</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="n">y</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformer</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">accuracy_score</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">classifier</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X</span><span class="p">),</span> <span class="n">sample_weight</span><span class="o">=</span><span class="n">sample_weight</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Finally, we're ready to see if this class works!</p>
<p>Let's generate some random data with 100 samples to test in a <code>Pipeline</code>. We'll cover exactly how <code>Pipelines</code> work in the next section so don't worry about the details here. We just want to make sure that we see strings instead of numbers as the output of a prediction, which, we do indeed see.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="mi">50</span><span class="p">)</span>
<span class="n">_X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="n">_X_test</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>

<span class="n">oe</span> <span class="o">=</span> <span class="n">Pipeline</span><span class="p">(</span>
    <span class="p">[</span>
        <span class="p">(</span><span class="s2">&quot;oe&quot;</span><span class="p">,</span> <span class="n">OrdinalEncoder</span><span class="p">()),</span>
        <span class="p">(</span><span class="s2">&quot;reshaper&quot;</span><span class="p">,</span> <span class="n">FunctionTransformer</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">x</span><span class="p">))),</span>
    <span class="p">]</span>
<span class="p">)</span>

<span class="n">lr</span> <span class="o">=</span> <span class="n">LogisticRegression</span><span class="p">()</span>
<span class="n">ttc</span> <span class="o">=</span> <span class="n">TransformedTargetClassifier</span><span class="p">(</span><span class="n">lr</span><span class="p">,</span> <span class="n">oe</span><span class="p">)</span>

<span class="n">ttc</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">_X</span><span class="p">,</span> <span class="n">_y</span><span class="p">)</span>
<span class="n">ttc</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">_X_test</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>array([&#39;a&#39;, &#39;a&#39;, &#39;a&#39;], dtype=object)</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Pipelines">Pipelines<a class="anchor-link" href="#Pipelines"> </a></h2><p><code>Pipelines</code> allow you to run multiple operations on an input dataset in succession before an estimation is performed. It was originally designed to be a linear step-by-step transformation template but there are now additional tools in the <code>Pipeline</code> toolkit that allow for horizontal joining of "columns". This is out of scope for this blog post but you can <a href="https://scikit-learn.org/stable/modules/generated/sklearn.pipeline.FeatureUnion.html#sklearn.pipeline.FeatureUnion">check out the docs for that here</a>.</p>
<p>The main use case for this approach becomes apparent when we look to perform experiments on a particular machine learning approach. Pipelines make it straightforward to perform cross validation and grid searching across both the feature engineering and estimator hyperparameters. Pipelines make it very hard to accidentally get your data into an improper state which often happens when you have the same input variable being modified across multiple jupyter notebook cells.</p>
<p>In the next two cells we define a <code>Pipeline</code> which is applied to our PBP dataset. Since the last step in the pipeline inherits from <code>BaseEstimtor</code> the pipeline behaves exactly like an estimator. (enabling methods like <code>predict</code> and <code>score</code>) When we call fit, each of the steps fits the transformer and transforms the data before passing it to the next step.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The following are descriptions of each of the steps across both estimators</p>
<ul>
<li>Feature Transformation<ul>
<li><code>DictVectorizer</code>: Converts the input column of dictionary values into a sparse nxm matrix where n is the number of rows and m is the number of unique prescriptions. The value in each cell is the frequency with which the drug was prescribed by a practitioner.</li>
<li><code>TfidfTransformer</code>: We can think of the above dictionary almost like a "document" with frequency counts of terms. Hence, we can use term frequency, inverse document frequency (TFIDF) to process those terms into a form that would be more meaningful for a classification model</li>
</ul>
</li>
<li>Response Transformation ( <code>TransformedTargetClassifier</code> )<ul>
<li>Transformer (also a <code>Pipeline</code>)<ul>
<li><code>JSONTargetSelector</code>: We supply this step a chosen response variable</li>
<li><code>OrdinalEncoder</code>: This step converts a list of strings into numbers incrementing one by one.</li>
<li><code>FunctionTransformer</code>: This step is a convenience method that allows us to apply a lambda function to the entire dataset. We make sure to reshape the data to a column vector as is required by most <code>sklearn</code> estimators</li>
</ul>
</li>
<li>Classifier<ul>
<li><code>LogisticRegression</code>: We choose to use logistic regression because it is the simplest classification model</li>
</ul>
</li>
</ul>
</li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Here we also <code>clone</code> <code>settlement_pipe</code> which duplicates its structure and parameters without keeping its state. We then swap out <code>JSONTargetSelector</code> with an instance that has the right target for the second pipeline.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">settlement_pipe</span> <span class="o">=</span> <span class="n">Pipeline</span><span class="p">(</span>
    <span class="p">[</span>
        <span class="p">(</span><span class="s2">&quot;dv&quot;</span><span class="p">,</span> <span class="n">DictVectorizer</span><span class="p">()),</span>
        <span class="p">(</span><span class="s2">&quot;tfidf&quot;</span><span class="p">,</span> <span class="n">TfidfTransformer</span><span class="p">()),</span>
        <span class="p">(</span>
            <span class="s2">&quot;ttc&quot;</span><span class="p">,</span>
            <span class="n">TransformedTargetClassifier</span><span class="p">(</span>
                <span class="n">classifier</span><span class="o">=</span><span class="n">LogisticRegression</span><span class="p">(</span><span class="n">max_iter</span><span class="o">=</span><span class="mi">1000</span><span class="p">),</span>
                <span class="n">transformer</span><span class="o">=</span><span class="n">Pipeline</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="p">[</span><span class="s2">&quot;jts&quot;</span><span class="p">,</span> <span class="n">JSONTargetSelector</span><span class="p">(</span><span class="s2">&quot;settlement_type&quot;</span><span class="p">,</span> <span class="n">two_d_out</span><span class="o">=</span><span class="kc">True</span><span class="p">)],</span>
                        <span class="p">(</span><span class="s2">&quot;enc&quot;</span><span class="p">,</span> <span class="n">OrdinalEncoder</span><span class="p">()),</span>
                        <span class="p">(</span><span class="s2">&quot;ft&quot;</span><span class="p">,</span> <span class="n">FunctionTransformer</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">x</span><span class="p">))),</span>
                    <span class="p">]</span>
                <span class="p">),</span>
            <span class="p">),</span>
        <span class="p">),</span>
    <span class="p">]</span>
<span class="p">)</span>
<span class="n">region_pipe</span> <span class="o">=</span> <span class="n">clone</span><span class="p">(</span><span class="n">settlement_pipe</span><span class="p">)</span>
<span class="n">region_pipe</span><span class="o">.</span><span class="n">steps</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">transformer</span><span class="o">.</span><span class="n">steps</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">JSONTargetSelector</span><span class="p">(</span>
    <span class="s2">&quot;region&quot;</span><span class="p">,</span> <span class="n">two_d_out</span><span class="o">=</span><span class="kc">True</span>
<span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">settlement_pipe</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">);</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">region_pipe</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">);</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Let's do some quick evaluations to see what the output looks like. Carefully selecting some specific rows which do not have too many prescriptions, we find the following output. Looks like 100% accuracy on this cherry picked, dataset... time to call it a day?</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">N</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="n">sample_X</span> <span class="o">=</span> <span class="n">json_normalize</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">N</span><span class="p">])</span>

<span class="n">preds_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
    <span class="nb">zip</span><span class="p">(</span>
        <span class="n">json_normalize</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">N</span><span class="p">])</span><span class="o">.</span><span class="n">settlement_type</span><span class="p">,</span>
        <span class="n">settlement_pipe</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">N</span><span class="p">]),</span>
        <span class="n">json_normalize</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">N</span><span class="p">])</span><span class="o">.</span><span class="n">region</span><span class="p">,</span>
        <span class="n">region_pipe</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">N</span><span class="p">]),</span>
    <span class="p">),</span>
    <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;settlement_type&quot;</span><span class="p">,</span> <span class="s2">&quot;settlement_type_hat&quot;</span><span class="p">,</span> <span class="s2">&quot;region&quot;</span><span class="p">,</span> <span class="s2">&quot;region_hat&quot;</span><span class="p">],</span>
<span class="p">)</span>
<span class="n">rslts_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">sample_X</span><span class="p">,</span> <span class="n">preds_df</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">rslts_df</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_html rendered_html output_subarea output_execute_result">
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>CEPHALEXIN</th>
      <th>AMOXICILLIN</th>
      <th>HYDROCODONE-ACETAMINOPHEN</th>
      <th>CLINDAMYCIN HCL</th>
      <th>settlement_type</th>
      <th>settlement_type_hat</th>
      <th>region</th>
      <th>region_hat</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>23.0</td>
      <td>52</td>
      <td>28.0</td>
      <td>NaN</td>
      <td>non-urban</td>
      <td>non-urban</td>
      <td>South</td>
      <td>South</td>
    </tr>
    <tr>
      <th>1</th>
      <td>28.0</td>
      <td>73</td>
      <td>NaN</td>
      <td>11.0</td>
      <td>non-urban</td>
      <td>non-urban</td>
      <td>Midwest</td>
      <td>Midwest</td>
    </tr>
    <tr>
      <th>2</th>
      <td>NaN</td>
      <td>63</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>non-urban</td>
      <td>non-urban</td>
      <td>South</td>
      <td>South</td>
    </tr>
  </tbody>
</table>
</div>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Anyways, when we actually score the models, we find the following training accuracies. Not too bad for no hyperparameter tuning.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">s_train_score</span> <span class="o">=</span> <span class="n">settlement_pipe</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
<span class="n">r_train_score</span> <span class="o">=</span> <span class="n">region_pipe</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
<span class="n">s_test_score</span> <span class="o">=</span> <span class="n">settlement_pipe</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">)</span>
<span class="n">r_test_score</span> <span class="o">=</span> <span class="n">region_pipe</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">)</span>

<span class="n">scores_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
    <span class="p">{</span>
        <span class="s2">&quot;settlement_type&quot;</span><span class="p">:</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">s_train_score</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">s_test_score</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">],</span>
        <span class="s2">&quot;region&quot;</span><span class="p">:</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">r_train_score</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">r_test_score</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">],</span>
    <span class="p">},</span>
    <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;train&quot;</span><span class="p">,</span> <span class="s2">&quot;test&quot;</span><span class="p">],</span>
<span class="p">)</span>

<span class="n">scores_df</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_html rendered_html output_subarea output_execute_result">
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>settlement_type</th>
      <th>region</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>train</th>
      <td>0.646</td>
      <td>0.462</td>
    </tr>
    <tr>
      <th>test</th>
      <td>0.636</td>
      <td>0.453</td>
    </tr>
  </tbody>
</table>
</div>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Further-Resources">Further Resources<a class="anchor-link" href="#Further-Resources"> </a></h2><p><strong>Future Work</strong></p>
<ul>
<li>One interesting improvement here could be to add an extra custom transformer before the <code>DictVectorizer</code>. One that removes frequent and infrequent medications may improve performance. You should have all the tools to add this step to the pipeline.</li>
<li>Another improvement to deepen your understanding of pipelines would be to try and see how you could use <code>GridSearchCV</code> to find a more optimal model. It would be especially useful to see how tuning interplays with your custom transformer from the previous step</li>
</ul>
<p><strong>Other Links</strong></p>
<p>The best place to learn more about these advanced <code>sklearn</code> features is actually their documentation. They have a user guide which is quite good, and their API is well documented as well. Additionally, I picked up most of the transformer tricks by reading the source code of the feature extraction transformers. If you have access to the PyCharm debugger, it is also really useful to step through the code as <code>Pipeline.fit</code> runs since a lot of functionality is abstracted away.</p>
<ul>
<li><a href="https://scikit-learn.org/stable/modules/classes.html">The API</a></li>
<li><a href="https://scikit-learn.org/stable/modules/compose.html">The Pipeline User Guide</a></li>
<li><a href="https://github.com/scikit-learn/scikit-learn/tree/main/sklearn/feature_extraction">The Feature Extraction Source Code</a></li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Appendix">Appendix<a class="anchor-link" href="#Appendix"> </a></h2>
</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">from</span> <span class="nn">nbformat</span> <span class="kn">import</span> <span class="n">read</span>

<span class="c1"># Default path for this notebook</span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;/work/notebook.ipynb&quot;</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">nb</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>

<span class="c1"># Count the number of lines in markdown or heading cells</span>
<span class="n">word_count</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span>
    <span class="p">[</span>
        <span class="nb">len</span><span class="p">(</span><span class="n">cell</span><span class="p">[</span><span class="s2">&quot;source&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;#&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">lstrip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">nb</span><span class="p">[</span><span class="s2">&quot;cells&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">cell</span><span class="o">.</span><span class="n">cell_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;markdown&quot;</span><span class="p">,</span> <span class="s2">&quot;heading&quot;</span><span class="p">]</span>
    <span class="p">]</span>
<span class="p">)</span>

<span class="c1"># Count number of lines in the notebook and subtract the number of</span>
<span class="c1"># lines in this cell</span>
<span class="n">line_count</span> <span class="o">=</span> <span class="p">(</span>
    <span class="nb">sum</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="c1"># Filter out cells that are comments or are empty</span>
            <span class="nb">len</span><span class="p">(</span>
                <span class="nb">list</span><span class="p">(</span>
                    <span class="nb">filter</span><span class="p">(</span>
                        <span class="k">lambda</span> <span class="n">line</span><span class="p">:</span> <span class="ow">not</span> <span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">lstrip</span><span class="p">()</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;#&quot;</span><span class="p">)),</span>
                        <span class="n">cell</span><span class="p">[</span><span class="s2">&quot;source&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">),</span>
                    <span class="p">)</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">nb</span><span class="p">[</span><span class="s2">&quot;cells&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">cell</span><span class="o">.</span><span class="n">cell_type</span> <span class="o">==</span> <span class="s2">&quot;code&quot;</span>
        <span class="p">]</span>
    <span class="p">)</span>
    <span class="o">-</span> <span class="mi">27</span>
<span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Word Count: </span><span class="si">{</span><span class="n">word_count</span><span class="si">:</span><span class="s2">,</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Line Count: </span><span class="si">{</span><span class="n">line_count</span><span class="si">:</span><span class="s2">,</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>Word Count: 2,114
Line Count: 206
</pre>
</div>
</div>

</div>
</div>

</div>
    {% endraw %}

</div>
 

